=for comment Documentation generated by YARD v0.6.4 and yard-pod-plugin v0.1.

=head1 NAME

Test::Mini::Assertions - Basic Assertions for Test::Mini

=head1 METHODS

=head2 Exported Functions

=over

=item B<<<< assert >>>>

    assert($test, $msg) 


Asserts that C<<<< $test >>>> is truthy, and throws a L<<<< S<<<<<
Test::Mini::Exception::Assert >>>>>|Test::Mini::Exception::Assert >>>>
if that assertion fails.


Examples:

    assert 1;
    
    assert 'true', 'Truth should shine clear';

Parameters:

=over

=item *

B<<<<< C<<<< $test >>>> >>>>> -- The value to test.


=item *

(I<<<< String >>>>) B<<<<< C<<<< $msg >>>> >>>>> -- An optional
description.


=back

=item B<<<< assert_block >>>>

    assert_block($block, $msg) 


    Deprecated. This assertion offers little advantage over the base L<<<<
    S<<<<< #assert >>>>>|Test::Mini::Assertions/assert >>>>. This will be
    removed in v2.0.0.


Asserts that the given code reference returns a truthy value.


Examples:

    assert_block { 'true' };
    
    assert_block \&some_sub, 'expected better from &some_sub';

Parameters:

=over

=item *

(I<<<< CODE >>>>) B<<<<< C<<<< $block >>>> >>>>> -- The code
reference to test.


=item *

(I<<<< String >>>>) B<<<<< C<<<< $msg >>>> >>>>> -- An optional
description.


=back

=item B<<<< assert_can >>>>

=item Aliased as: I<<<< assert_responds_to >>>>

    assert_can($obj, $method, $msg) 


Verifies that the given C<<<< $obj >>>> is capable of responding to the
given C<<<< $method >>>> name.


Examples:

    assert_can $date, 'day_of_week';
    
    assert_can $time, 'seconds', '$time cannot respond to #seconds';

Parameters:

=over

=item *

B<<<<< C<<<< $obj >>>> >>>>> -- The object being tested.


=item *

(I<<<< String >>>>) B<<<<< C<<<< $method >>>> >>>>> -- The method
name being checked for.


=item *

(I<<<< String >>>>) B<<<<< C<<<< $msg >>>> >>>>> -- An optional
description.


=back

=item B<<<< assert_contains >>>>

=item Aliased as: I<<<< assert_includes >>>>

    assert_contains($collection, $obj, $msg) 


Verifies that the given C<<<< $collection >>>> contains the given C<<<<
$obj >>>> as a member.


Examples:

    assert_contains [qw/ 1 2 3 /], 2;
    
    assert_contains { a => 'b' }, 'a';  # 'b' also contained
    
    assert_contains 'expectorate', 'xp';
    
    assert_contains Collection->new(1, 2, 3), 2;  # if Collection->contains(2)

Parameters:

=over

=item *

(I<<<< Array|Hash|String|#contains >>>>) B<<<<< C<<<< $collection
>>>> >>>>> -- The collection to test.


=item *

B<<<<< C<<<< $obj >>>> >>>>> -- The needle to find.


=item *

(I<<<< String >>>>) B<<<<< C<<<< $msg >>>> >>>>> -- An optional
description.


=back

=item B<<<< assert_defined >>>>

=item Aliased as: I<<<< refute_undef >>>>

    assert_defined($obj, $msg) 


Validates that the given C<<<< $obj >>>> is defined.


Examples:

    assert_defined $value;  # if defined $value

Parameters:

=over

=item *

B<<<<< C<<<< $obj >>>> >>>>> -- The value to check.


=item *

(I<<<< String >>>>) B<<<<< C<<<< $msg >>>> >>>>> -- An optional
description.


=back

=item B<<<< assert_dies >>>>

    assert_dies($sub, $error, $msg) 


Tests that the supplied code block dies, and fails if it succeeds.  If
C<<<< $error >>>> is provided, the error message in C<<<< $@ >>>> must
contain it.


Examples:

    assert_dies { die 'LAGHLAGHLAGHL' };
    
    assert_dies { die 'Failure on line 27 in Foo.pm' } 'line 27';

Parameters:

=over

=item *

(I<<<< CODE >>>>) B<<<<< C<<<< $sub >>>> >>>>> -- The code that
should die.


=item *

(I<<<< String >>>>) B<<<<< C<<<< $error >>>> >>>>> -- The (optional)
error substring expected.


=item *

(I<<<< String >>>>) B<<<<< C<<<< $msg >>>> >>>>> -- An optional
description.


=back

=item B<<<< assert_empty >>>>

    assert_empty($collection, $msg) 


Verifies the emptiness of a collection.


Examples:

    assert_empty [];
    
    assert_empty {};
    
    assert_empty '';
    
    assert_empty Collection->new();  # if Collection->new()->is_empty()

Parameters:

=over

=item *

(I<<<< Array|Hash|String|#is_empty >>>>) B<<<<< C<<<< $collection
>>>> >>>>> -- The collection under scrutiny.


=item *

(I<<<< String >>>>) B<<<<< C<<<< $msg >>>> >>>>> -- An optional
description.


=back

=item B<<<< assert_equal >>>>

=item Aliased as: I<<<< assert_eq >>>>

    assert_equal($actual, $expected, $msg) 


Checks two given arguments for equality.


Examples:

    assert_equal 3.000, 3;
    
    assert_equal lc('FOO'), 'foo';
    
    assert_equal [qw/ 1 2 3 /], [ 1, 2, 3 ];
    
    assert_equal { a => 'eh' }, { a => 'eh' };
    
    assert_equal Class->new(), $expected;  # if $expected->equals(Class->new())

Parameters:

=over

=item *

B<<<<< C<<<< $actual >>>> >>>>> -- The value under test.


=item *

B<<<<< C<<<< $expected >>>> >>>>> -- The expected value.


=item *

(I<<<< String >>>>) B<<<<< C<<<< $msg >>>> >>>>> -- An optional
description.


=back

=item B<<<< assert_in_delta >>>>

    assert_in_delta($actual, $expected, $delta, $msg) 


Checks that the difference between C<<<< $actual >>>> and C<<<<
$expected >>>> is less than C<<<< $delta >>>>.


Examples:

    assert_in_delta 1.001, 1;
    
    assert_in_delta 104, 100, 5;

Parameters:

=over

=item *

(I<<<< Number >>>>) B<<<<< C<<<< $actual >>>> >>>>> -- The tested
value.


=item *

(I<<<< Number >>>>) B<<<<< C<<<< $expected >>>> >>>>> -- The static
value.


=item *

(I<<<< Number >>>>) B<<<<< C<<<< $delta >>>> >>>>> -- The expected
delta.  Defaults to 0.001.


=item *

(I<<<< String >>>>) B<<<<< C<<<< $msg >>>> >>>>> -- An optional
description.


=back

=item B<<<< assert_in_epsilon >>>>

    assert_in_epsilon($actual, $expected, $epsilon, $msg) 


Checks that the difference between C<<<< $actual >>>> and C<<<<
$expected >>>> is less than a given fraction of the smaller of the two
numbers.


Examples:

    assert_in_epsilon 22.0 / 7.0, Math::Trig::pi;
    
    assert_in_epsilon 220, 200, 0.10

Parameters:

=over

=item *

(I<<<< Number >>>>) B<<<<< C<<<< $actual >>>> >>>>> -- The tested
value.


=item *

(I<<<< Number >>>>) B<<<<< C<<<< $expected >>>> >>>>> -- The static
value.


=item *

(I<<<< Number >>>>) B<<<<< C<<<< $epsilon >>>> >>>>> -- The expected
tolerance factor.  Defaults to 0.001.


=item *

(I<<<< String >>>>) B<<<<< C<<<< $msg >>>> >>>>> -- An optional
description.


=back

=item B<<<< assert_instance_of >>>>

    assert_instance_of($obj, $type, $msg) 


Validates that the given object is an instance of C<<<< $type >>>>.


Examples:

    assert_instance_of MyApp::Person->new(), 'MyApp::Person';

Parameters:

=over

=item *

B<<<<< C<<<< $obj >>>> >>>>> -- The instance to check.


=item *

(I<<<< Class >>>>) B<<<<< C<<<< $type >>>> >>>>> -- The type to
expect.


=item *

(I<<<< String >>>>) B<<<<< C<<<< $msg >>>> >>>>> -- An optional
description.


=back


See Also:

=over

=item *

L<<<< S<<<<< #assert_is_a >>>>>|Test::Mini::Assertions/assert_is_a >>>>


=back

=item B<<<< assert_is_a >>>>

=item Aliased as: I<<<< assert_isa >>>>

    assert_is_a($obj, $type, $msg) 


Validates that C<<<< $obj >>>> inherits from C<<<< $type >>>>.


Examples:

    assert_is_a 'Employee', 'Employee';
    
    assert_is_a Employee->new(), 'Employee';
    
    assert_is_a 'Employee', 'Person'; # assuming Employee->isa('Person')
    
    assert_is_a Employee->new(), 'Person';

Parameters:

=over

=item *

B<<<<< C<<<< $obj >>>> >>>>> -- The instance or class to check.


=item *

(I<<<< Class >>>>) B<<<<< C<<<< $type >>>> >>>>> -- The expected
superclass.


=item *

(I<<<< String >>>>) B<<<<< C<<<< $msg >>>> >>>>> -- An optional
description.


=back

=item B<<<< assert_match >>>>

    assert_match($string, $pattern, $msg) 


Validates that the given C<<<< $string >>>> matches the given C<<<<
$pattern >>>>.


Examples:

    assert_match 'Four score and seven years ago...', qr/score/;

Parameters:

=over

=item *

(I<<<< String >>>>) B<<<<< C<<<< $string >>>> >>>>> -- The string to
match.


=item *

(I<<<< Regex >>>>) B<<<<< C<<<< $pattern >>>> >>>>> -- The regular
expression to match against.


=item *

(I<<<< String >>>>) B<<<<< C<<<< $msg >>>> >>>>> -- An optional
description.


=back

=item B<<<< assert_undef >>>>

=item Aliased as: I<<<< refute_defined >>>>

    assert_undef($obj, $msg) 


Validates that the given C<<<< $obj >>>> is undefined.


Examples:

    assert_undef $value;  # if not defined $value

Parameters:

=over

=item *

B<<<<< C<<<< $obj >>>> >>>>> -- The value to check.


=item *

(I<<<< String >>>>) B<<<<< C<<<< $msg >>>> >>>>> -- An optional
description.


=back

=item B<<<< flunk >>>>

    flunk($msg) 


Causes the current test to exit immediately with a failing status.



Parameters:

=over

=item *

(I<<<< String >>>>) B<<<<< C<<<< $msg >>>> >>>>> -- An optional
description.


=back

=item B<<<< refute >>>>

    refute($test, $msg) 


Asserts that C<<<< $test >>>> is falsey, and throws a L<<<< S<<<<<
Test::Mini::Exception::Assert >>>>>|Test::Mini::Exception::Assert >>>>
if that assertion fails.


Examples:

    refute 0;
    
    refute undef, 'Deny the untruths';

Parameters:

=over

=item *

B<<<<< C<<<< $test >>>> >>>>> -- The value to test.


=item *

(I<<<< String >>>>) B<<<<< C<<<< $msg >>>> >>>>> -- An optional
description.


=back

=item B<<<< refute_block >>>>

    refute_block($block, $msg) 


    Deprecated. This assertion offers little advantage over the base L<<<<
    S<<<<< #refute >>>>>|Test::Mini::Assertions/refute >>>>. This will be
    removed in v2.0.0.


Asserts that the given code reference returns a falsey value.


Examples:

    refute_block { '' };
    
    refute_block \&some_sub, 'expected worse from &some_sub';

Parameters:

=over

=item *

(I<<<< CODE >>>>) B<<<<< C<<<< $block >>>> >>>>> -- The code
reference to test.


=item *

(I<<<< String >>>>) B<<<<< C<<<< $msg >>>> >>>>> -- An optional
description.


=back

=item B<<<< refute_can >>>>

=item Aliased as: I<<<< refute_responds_to >>>>

    refute_can($obj, $method, $msg) 


Verifies that the given C<<<< $obj >>>> is B<<<< not >>>> capable of
responding to the given C<<<< $method >>>> name.


Examples:

    refute_can $date, 'to_time';
    
    refute_can $time, 'day', '$time cannot respond to #day';

Parameters:

=over

=item *

B<<<<< C<<<< $obj >>>> >>>>> -- The object being tested.


=item *

(I<<<< String >>>>) B<<<<< C<<<< $method >>>> >>>>> -- The method
name being checked.


=item *

(I<<<< String >>>>) B<<<<< C<<<< $msg >>>> >>>>> -- An optional
description.


=back

=item B<<<< refute_contains >>>>

    refute_contains($collection, $obj, $msg) 


Verifies that the given C<<<< $collection >>>> does not contain the
given C<<<< $obj >>>> as a member.


Examples:

    refute_contains [qw/ 1 2 3 /], 5;
    
    refute_contains { a => 'b' }, 'x';
    
    refute_contains 'expectorate', 'spec';
    
    refute_contains Collection->new(1, 2, 3), 5;  # unless Collection->contains(5)

Parameters:

=over

=item *

(I<<<< Array|Hash|String|#contains >>>>) B<<<<< C<<<< $collection
>>>> >>>>> -- The collection to test.


=item *

B<<<<< C<<<< $obj >>>> >>>>> -- The needle to look for.


=item *

(I<<<< String >>>>) B<<<<< C<<<< $msg >>>> >>>>> -- An optional
description.


=back

=item B<<<< refute_empty >>>>

    refute_empty($collection, $msg) 


Verifies the non-emptiness of a collection.


Examples:

    refute_empty [ 1 ];
    
    refute_empty { a => 1 };
    
    refute_empty 'full';
    
    refute_empty Collection->new();  # unless Collection->new()->is_empty()

Parameters:

=over

=item *

(I<<<< Array|Hash|String|#is_empty >>>>) B<<<<< C<<<< $collection
>>>> >>>>> -- The collection under scrutiny.


=item *

(I<<<< String >>>>) B<<<<< C<<<< $msg >>>> >>>>> -- An optional
description.


=back

=item B<<<< refute_equal >>>>

=item Aliased as: I<<<< refute_eq >>>>

    refute_equal($actual, $unexpected, $msg) 


Checks two given arguments for inequality.


Examples:

    refute_equal 3.001, 3;
    
    refute_equal lc('FOOL'), 'foo';
    
    refute_equal [qw/ 1 23 /], [ 1, 2, 3 ];
    
    refute_equal { a => 'ae' }, { a => 'eh' };
    
    refute_equal Class->new(), $expected;  # unless $expected->equals(Class->new())

Parameters:

=over

=item *

B<<<<< C<<<< $actual >>>> >>>>> -- The value under test.


=item *

B<<<<< C<<<< $expected >>>> >>>>> -- The tested value.


=item *

(I<<<< String >>>>) B<<<<< C<<<< $msg >>>> >>>>> -- An optional
description.


=back

=item B<<<< refute_in_delta >>>>

    refute_in_delta($actual, $expected, $delta, $msg) 


Checks that the difference between C<<<< $actual >>>> and C<<<<
$expected >>>> is greater than C<<<< $delta >>>>.


Examples:

    refute_in_delta 1.002, 1;
    
    refute_in_delta 106, 100, 5;

Parameters:

=over

=item *

(I<<<< Number >>>>) B<<<<< C<<<< $actual >>>> >>>>> -- The tested
value.


=item *

(I<<<< Number >>>>) B<<<<< C<<<< $expected >>>> >>>>> -- The static
value.


=item *

(I<<<< Number >>>>) B<<<<< C<<<< $delta >>>> >>>>> -- The delta
C<<<< $actual >>>> and C<<<< $expected >>>> are expected to differ
by.  Defaults to 0.001.


=item *

(I<<<< String >>>>) B<<<<< C<<<< $msg >>>> >>>>> -- An optional
description.


=back

=item B<<<< refute_in_epsilon >>>>

    refute_in_epsilon($actual, $expected, $epsilon, $msg) 


Checks that the difference between C<<<< $actual >>>> and C<<<<
$expected >>>> is greater than a given fraction of the smaller of the
two numbers.


Examples:

    refute_in_epsilon 21.0 / 7.0, Math::Trig::pi;
    
    refute_in_epsilon 220, 200, 0.20

Parameters:

=over

=item *

(I<<<< Number >>>>) B<<<<< C<<<< $actual >>>> >>>>> -- The tested
value.


=item *

(I<<<< Number >>>>) B<<<<< C<<<< $expected >>>> >>>>> -- The static
value.


=item *

(I<<<< Number >>>>) B<<<<< C<<<< $epsilon >>>> >>>>> -- The factor
by which C<<<< $actual >>>> and C<<<< $expected >>>> are expected to
differ by.  Defaults to 0.001.


=item *

(I<<<< String >>>>) B<<<<< C<<<< $msg >>>> >>>>> -- An optional
description.


=back

=item B<<<< refute_match >>>>

    refute_match($string, $pattern, $msg) 


Validates that the given C<<<< $string >>>> does not match the given
C<<<< $pattern >>>>.


Examples:

    refute_match 'Four score and seven years ago...', qr/score/;

Parameters:

=over

=item *

(I<<<< String >>>>) B<<<<< C<<<< $string >>>> >>>>> -- The string to
match.


=item *

(I<<<< Regex >>>>) B<<<<< C<<<< $pattern >>>> >>>>> -- The regular
expression to match against.


=item *

(I<<<< String >>>>) B<<<<< C<<<< $msg >>>> >>>>> -- An optional
description.


=back

=item B<<<< skip >>>>

    skip($msg) 


Allows the current test to be bypassed with an indeterminate status.



Parameters:

=over

=item *

(I<<<< String >>>>) B<<<<< C<<<< $msg >>>> >>>>> -- An optional
description.


=back

=back

=head2 Class Methods

=over

=item B<<<< import >>>>

    import($class) 


Pulls all of the test-related methods into the calling package.

=back

